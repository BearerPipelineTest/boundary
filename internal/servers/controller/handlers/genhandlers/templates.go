package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"text/template"
)

const (
	delete = "delete"
)

var actionFileMap = map[string]*template.Template{
	delete: deleteTemplate,
}

type templateInput struct {
	Package         string
	ResourceName    string
	Subtypes map[string]stubtypeInfo
	TypePackage string
}

func fillTemplates() {
	os.Setenv("HANDLERS_GEN_BASEPATH", "internal/servers/controller/handlers")
	for _, in := range inStruct {
		tin := templateInput{
			Package:         in.Package,
			ResourceName:    in.ResourceName,
			Subtypes: in.subtypes,
			TypePackage: in.topTypePackage,
		}

		outDir := filepath.Join(os.Getenv("HANDLERS_GEN_BASEPATH"), in.Package)
		if _, err := os.Stat(outDir); os.IsNotExist(err) {
			_ = os.Mkdir(outDir, os.ModePerm)
		}
		fmt.Println("Directory now exists: ", outDir)

		for _, a := range in.actions {
			tpl, ok := actionFileMap[a]
			if !ok {
				fmt.Printf("Unable to find template for action %q", a)
				os.Exit(1)
			}

			outBuf := new(bytes.Buffer)
			err := tpl.Execute(outBuf, tin)
			if err != nil {
				fmt.Printf("Got error %q", err)
				os.Exit(1)
			}

			outFile, err := filepath.Abs(fmt.Sprintf("%s/%s.gen.go", outDir, a))
			fmt.Println("Generating outputfile: ", outFile)
			if err != nil {
				fmt.Printf("error opening file %q: %v\n", outFile, err)
				os.Exit(1)
			}

			if err := ioutil.WriteFile(outFile, outBuf.Bytes(), 0o644); err != nil {
				fmt.Printf("error writing file %q: %s", outFile, err)
				os.Exit(1)
			}
		}
	}
}

var deleteTemplate = template.Must(template.New("").Parse(`// Code generated by "make handlers"; DO NOT EDIT.
package {{ .Package }}

import (
	"context"

	"github.com/hashicorp/boundary/internal/errors"
	pbs "github.com/hashicorp/boundary/internal/gen/controller/api/services"
	"github.com/hashicorp/boundary/internal/types/action"
	"github.com/hashicorp/boundary/internal/servers/controller/handlers"
)

type deleteRequest = *pbs.Delete{{ .ResourceName }}Request
type deleteResponse = *pbs.Delete{{ .ResourceName }}Response

// Delete{{ .ResourceName }} implements the interface pbs.CredentialLibraryServiceServer.
func (s Service) Delete{{ .ResourceName }}(ctx context.Context, req deleteRequest) (deleteResponse, error) {
	if err := validateDeleteRequest(req); err != nil {
		return nil, err
	}
	authResults := s.authResult(ctx, req.GetId(), action.Delete)
	if authResults.Error != nil {
		return nil, authResults.Error
	}
	_, err := s.deleteFromRepo(ctx, authResults.Scope.GetId(), req.GetId())
	if err != nil {
		return nil, err
	}
	return nil, nil
}

func (s Service) deleteFromRepo(ctx context.Context, scopeId, id string) (bool, error) {
	const op = "{{ .Package }}.(Service).deleteFromRepo"
	var rows int
	var err error
	{{ if eq (len .Subtypes) 1 }}
	repo, iErr := s.repoFn()
	if iErr != nil {
		return false, iErr
	}
	rows, err = repo.Delete{{ $.ResourceName }}(ctx, scopeId, id)
	{{ else }}
	switch {{ $.TypePackage }}.SubtypeFromId(id) {
	{{ range $k, $v := .Subtypes }}
	case {{$.TypePackage}}.{{ $k }}:
		repo, iErr := s.{{ $v.RepoName }}()
		if iErr != nil {
			return false, iErr
		}
		rows, err = repo.Delete{{ $.ResourceName }}(ctx, scopeId, id)
	{{ end }}
	default:
		// We don't know the type being deleted
		return false, nil
    }
	{{ end }}
	if err != nil {
		if errors.IsNotFoundError(err) {
			return false, nil
		}
		return false, errors.Wrap(err, op, errors.WithMsg("unable to delete resource"))
	}
	return rows > 0, nil
}

func validateDeleteRequest(req deleteRequest) error {
	return handlers.ValidateDeleteRequest(handlers.NoopValidatorFn, req, {{ range $k, $v := .Subtypes }}{{ range $v.PrefixVariable }}{{ . }},{{ end }}{{ end }})
}
`))

